<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <link rel="stylesheet" href="./css/style.css">
    <title>CSE163 Archive</title>
  </head>
  <body>
    
    
    

    <div class="container-fluid px-0 m-0 navbar navbar-dark navbar-expand-lg nav-color" id="mainNav">
      <!-- Content here -->
      <nav class="container m-0">
	<!-- Navbar content -->
	
	<a class="navbar-brand mr-5 font-weight-bold text-warning" href="#">CSE163</a>
	<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
	  <span class="navbar-toggler-icon"></span>
	</button>

	<div class="collapse navbar-collapse" id="navbarSupportedContent">
	  <ul class="navbar-nav mr-auto">
	    <li class="nav-item active">
	      <a class="nav-link" href="./index.html#">Home <span class="sr-only">(current)</span></a>
	    </li>
	    <li class="nav-item dropdown">
	      <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
		Assignments
	      </a>

	    </li>
	  </ul>
	</div>
	
      </nav>
      <!-- end of container -->
    </div>

    <div class="jumbotron">

      <div class="container">
	
	<h1 class="display-4">Mesh Simplication & Progressive Recover</h1>
	<p class="lead">We reference Garlandâ€™s 97 paper & Hoppe's 96 paper to implement a mesh simplification by collapsing edges between two vertices according to an error metrics calculation and recovering the original mesh model by splitting the vertices that have been collapsed before. </p>
	<hr class="my-4">
      </div>

    </div>
    

    <div class="essay container">
      
      <dl class="row">
	<h1 class="display-5 col-md-8">Part 1: Mesh Viewer </h1>
	<div class="col-md-4 pt-5">
	  <p class="text-left">Related Class: Mesh, Face, Vertex, Camera</p>
	</div>

      </dl>
      
      <ol>
	<li>
		<h4>Skeleton Code: </h4>
		<p> The base code of our program is taken from the provided skeleton code in the previous iterations of the CSE 167 class. 
		This code contains the basic initialization process to set up an OpenGL window. We build upon this code by adding a file parser, a Mesh class, and basic shaders. 
		As a result, the program is able to display the model, centered and scaled to a 10x10x10 cube, on a solid black background. 
		</p>
	</li>

	<li>
	  <h4>Mesh Perception: </h4>
	  <p> In order to test out the normal calculation and the mesh simplification, we need to have a way to "feel" the differences between a coarse mesh
	    model and a fine mesh model. We conquer this obstacle by using Gouraud shading. This shading allows us to see the diffuse and
	    specular highlights, which varies on different faces. It also gives the mesh structure depth and perception under basic lighting.
	    This approach enables us to test out our normal calculations. What's more, to better see the mesh structure, we enable
	    the wireframe modeling in the OpenGL initialization. You can toggle it by pressing 'F5' key to switch between the modes.
	  </p>
	  <div class="row pb-5">
	    <div class="col-md-6">
	      <img src="./images/gourd.png" class="img-fluid" alt="gourd shading of cow">
	    </div>
	    <div class="col-md-6">
	      <img src="./images/wireframe.png" class="img-fluid" alt="wireframe of cow">
	    </div>
	  </div>
	  <p class="text-center mx-auto"><small>Toggle between two different mode by pressing 'F5'</small></p>
	</li>

	
	<li>
	  <h4>Interaction With the Model: </h4>
	  <p>To interact with the model, we create a FPS like experience to wander around the scene by using the 'w', 'a', 's', and 'd' keys to move the camera's position
	    and the mouse to rotate the view angle. We do this by first setting up a Camera class to calculate the view matrix according to the camera's position in space and its focus on the scence. 
	    We let the Camera class process our keyboard and mouse input and adjust its position and
	    view angle according to these inputs. Then, in the game loop, before drawing, we update our wiew matrix using the Camera class. Also, the camera position is given to the shader for rendering the lighting.
	    In order for you to control the use of the mouse, you can press 'F6' to enable/disable the mouse.
	  </p>
	</li>
      </ol>

      <hr class="my-4 my-4">
      <dl class="row mt-5">
	<h1 class="display-5 col-md-8">Part 2: Data Structure Design </h1>
	<div class="col-md-4 pt-5">
	  <p class="text-left">Related Class: Face, Vertex, Mesh, Errdge</p>
	</div>	  
      </dl>
      <ol>
	<li>
	  <h4>Overview: </h4>
	  <p> To implement a good data structure, the mesh manipulation is not the only key we need to deal with. The runtime of an edge collapse and a
	    vertex split, the memory management of faces and vertices, and the proper maintenance of the connectivity structure are also
	    three important concerns. Making the code simple allows it to be maintainable and fast enough to perform the mesh simplification and
	    progressive meshes. The follwing picture is the simplified UML diagram of our data structure relationship.
	  </p>
		
	  <p>
	    For the reasons stated above, we decided to use the simple adjacency list data structure. We have three main classes: Vertex, Face, and Mesh. 
	    Each of these classes represent what their names suggest (i.e. Vertex represents a vertex). The Mesh class is the container class which holds a list of vertices and faces that make up the mesh, 
	    and the connectivity information is stored within the Face and Vertex classes. That is to say,     
	    each Face holds a list of Vertex pointers that make up the face, while each Vertex holds a list of the
	    Faces that are adjacent to it. Errdge, on the other hand, is a supplementary class that is only used for storing the information of an edge collapse. 
	    This includes the two vertices that make up the edge, the position of new merged vertex, and the error corresponding to the edge collapse. 
	    This class facilitates the recalculation of the error whenever a new edge is collapsed, making it a good auxiliary class for containers such as stacks or queues.
	  </p>

	  <div class="row pb-5">
	    <div class="col-md-12">
	      <img src="./images/datastructure.jpeg" class="img-fluid" alt="uml of data structure">
	    </div>
	  </div>
	  <p class="text-left my-2"><small>UML of data structure</small></p>

	</li>
	      
	<li>
	  <h4>Data Import: </h4>
	  <p> To read in the model's data from the OFF files, we mainly use a stringstream class. We first create a Mesh object, which contains an array of Vertex pointers and another array of Face pointers.
	    For each line in the file specifying a vertex, we create a Vertex object on the heap, pass in its x, y, and z coordinates, and add this to the Mesh. Next, for each line in the file specifying a face, we create a Face object on the heap, pass in the Vertex pointers from the Mesh's vertex array
	    using the indices parsed from the file, and add this Face to the Mesh. We then add this Face to the adjacency list of each of its vertices. After parsing (and after every edge collapse or vertex split), we dump all the positions of the vertices and all the indices of the faces' vertices from the Mesh to an array.
	    This array is then passed to the VBO and EBO for OpenGL to render the model.
	  </p>
	</li>
	      
	
	  <h4>Run-time Analysis: </h4>
	  <ol>
	    <li >
	      <p class="m-0">Picking an Edge: </p>
	      <p>
		To store the Errdge objects, we use a min heap. Initializing this heap with all the possible edges takes a single O(N log N) time. Picking an edge in each iteration of an edge collapse takes O(log N) time. And finally, adding the new edges (after collapsing edges) will also take O(log N) time.
	      </p>
	    </li>
	    <li>
	      <p class="m-0">Updating Adjacency List: </p>
	      <p>
		Because we deal with pointers and only update locally, with respect to the edge, updating the adjacency list should run in constant time. 
		To update the adjcency list of the faces and vertices that were affected by the edge collapse, we only have to replace the pointer information, which is just a value assignment. The total number of faces and vertices that have to be updated is also constant since they are simply the neighbors of the vertices that were collapsed. 
		As for the faces that collapse as a result of the edge collapse, we toggle a flag in the object that indicates the face being invalid and not part of the simplified model. These show that updating the adjacency list takes constant time.
	      </p>
	    </li>
	    <li>
	      <p class="m-0">Total: </p>
	      <p>
		 From the analyses above, performing an edge collapse will take O(log N) time with respect to the number of edges. However, we note that for smaller values, recalculating the error and optimal vertex position might dominate the run time since it uses matrix operations. 
		 As for vertex splits, the runtime should be constant since we maintain a history stack that shows which vertices split into which other vertices. This means that there is no calculation required for vertex splits.
	      </p>
	    </li>   
	  </ol>
	</li>

	<li>
	  <h4>Memory Management: </h4>
	  <p>In the edge collapse function, instead of deleting, we mark each vertex and face that are not going to be rendered as "dead". These "dead" vertices and faces are then skipped when transferring the vertices and faces into arrays for the VBO and EBO.
	     The reason we did this is because of two things, simplifying the vertex split function and consolidating the dynamic memory. By keeping the "dead' vertices and faces, we avoid having to recreate these objects and instead, simply toggle a flag. 
	     Also, by keeping these dynamically allocated objects in a single container, we avoid having to release memory in many different places in the code. Instead, freeing the memory can be done in the end, with a simple for loop.
	  </p>	  
      </ol>



      <hr class="my-4 my-4">
      <dl class="row mt-5">
	<h1 class="display-5 col-md-8">Part 3: Mesh Simpification </h1>
	<div class="col-md-4 pt-5">
	  <p class="text-left">Related Class: Face, Vertex, Mesh, Errdge</p>
	</div>	  
      </dl>
      <ol>
	<li>
	  <h4>Edge Collapsing Algorithm: </h4>
	  <p>
	    In our implementation, the edge collase function takes in a Errdge object. We first retrieve the two vertices to be removed from the Errdge and
	    instantiate a new vertex on the heap by using the new position with the least error, which is already calculated in the Errdge object.
	  </p>
	  <p>
	    Let the two vertices to be removed be v1, v2 and the new vertex to be v'.
	  </p>
	  <p>
	    For each face in both v1's and v2's adjacent list, we find the common faces and terminate them. Next, for the remaining faces that were not terminated, we replace v1 or v2 with v' from the face's adjacency list. 
	    We then update the normals of these remaining faces to reflect the new vertex. 
	    Following that, we iterate through each of the neighbors (vertices in the adjacency list of the faces that are in the adjacency list of the new vetex) and update their adjacency list (remove any terminated faces) and their normals.
	    Lastly, we make new Errdges(Edges with Error) between the new vertex and its neighbors. This includes calculating the error matrics and adding these Errdges into the min heap structure. In the end, we also terminate v1 and v2 in order to not render them.
	  </p>
	</li>


	<li>
	  <h4>Corner Case (Fins): </h4>
	    <p>
	      The algorithm described above is not enough for some special cases, which can lead to a fins appearing on the surface of the model, making the model
	      appear disasterous and also influencing the error matrics calculation in some areas. See the following picture taken from the assignment write-up.
	    </p>

	    <div class="row pb-5">
	      <div class="col-md-12">
		<img src="./images/special-case.png" class="img-fluid" alt="special case for edge collapsing">
	      </div>
	    </div>
	    
	    <h5>Our Solution: </h5>
          <p>We observe from the pictures that the fin is caused by two faces sharing the same vertex set after the edge collapse.
	    This gives us a simple algorithm to detect these fins and remove them accordingly.
	  </p>
		
	  <p>Adding on to the edge collapse algorithm above, just after we replace v1 or v2 with v', we check for possible fins.
	    We do this through the use of a nested-for loop that compares each face adjacent to v' with every other face adjacent to v'. 
	    For each pair of faces, we add both faces' adjacent vertices into an unordered set. If, after inserting all the vertices from two different active faces into the set, the size of the set still remains as 3, it means that these two faces share the same vertex set (both are fins).
	    Ins this case, we terminate both faces. After checking for fins, we continue with the algorithm above and update the faces and neighboring vertices.
	  </p>

	  <div class="row pt-5">
	    <div class="col-md-6">
	      <img src="./images/original_wireframe.png" class="img-fluid" alt="original_wireframe">
	    </div>
	    <div class="col-md-6">
	      <img src="./images/original_gouraud.png" class="img-fluid" alt="original_gouraud">
	    </div>
	    <p class="text-center m-auto"><small>Before Collapsing</small></p>
	  </div>
	  
	  <div class="row">
	    <div class="col-md-6">
	      <img src="./images/fin_wireframe.png" class="img-fluid" alt="uml of data structure">
	    </div>
	    <div class="col-md-6">
	      <img src="./images/fin_gouraud.png" class="img-fluid" alt="uml of data structure">
	    </div>
	    <p class="text-center m-auto"><small>Redandunt Faces: Fin</small></p>
	  </div>

	  <div class="row pb-5">
	    <div class="col-md-6">
	      <img src="./images/perfect_wireframe.png" class="img-fluid" alt="perfect_wireframe">
	    </div>
	    <div class="col-md-6">
	      <img src="./images/perfect_gouraud.png" class="img-fluid" alt="perfect_gouraud">
	    </div>
	    <p class="text-center m-auto"><small>Perfect Solution</small></p>
	  </div>

	  
	</li>
	
      </ol>

      
    </div>

    
    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
  </body>
</html>
